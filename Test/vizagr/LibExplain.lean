import Vizagrams.VizPrim
import Vizagrams.VizBackend
import Vizagrams.VizMark
import Vizagrams.FreeMonad

open GeometricPrimitive
open VizBackend
open GraphicalPrimitive
open ProofWidgets Svg
open GraphicalMark

/- 1. Entendendo os objetos gr√°ficos -/

/-
Temos 4 tipos diferentes de objetos desenhaveis

¬∑ Prim ( Representa Primitivas)
¬∑ Array Prim ( Representa uma "lista ordenada" de primitivas)
¬∑ Mark ( Type que possui uma instancia de MarkInteface Œ∏ : Type ‚Üí Array Prim)
¬∑ ùïã Mark ( Free Monad em Endofuctors Mark )

Vamos observar como esses objetos se relacionam
-/

-- Vamos desenhar um C√≠rculo como uma primitiva
def circle‚Çö : Prim := NewCircle 1 ‚äû[0,0] -- Utilizamos NewCircle de VizBackend
#eval circle‚Çö
/-
{ geom := Geom.circle 1.000000 ‚äû[0.000000, 0.000000],
  s := Style.mk { strokeColor := none, strokeWidth := none, fillColor := (0.000000, 0.000000, 0.000000) } }
-/
-- Vamos verificar que circle‚Çö pode ser considerado um Array Prim
#check (circle‚Çö : Array Prim) -- #[circle‚Çö] : Array Prim

def circle‚Çê : Array Prim := circle‚Çö
#eval circle‚Çê
/-
#[{ geom := Geom.circle 1.000000 ‚äû[0.000000, 0.000000],
    s := Style.mk { strokeColor := none,
                    strokeWidth := none,
                    fillColor := (0.000000, 0.000000, 0.000000) } }]
-/

-- E como uma Mark ?
#check ( circle‚Çö : Mark ) -- Mark.mk circle‚Çö : Mark
def circle‚Çò : Mark := circle‚Çö
#eval circle‚Çò -- Alterar toString de Prim
/- Podemos fazer uma coer√ß√£o Prim ‚Üí Mark, mas ainda n√£o podemos fazer Array Prim ‚Üí Mark
Verificar se faz sentido pensar em uma coe Array Prim ‚Üí Mark pois o usu√°rio trabalhar√°
apenas com objetos do tipo Mark ou ùïã Mark
-/

-- E de circle para ùïã Mark ?
#check (circle‚Çö : FreeMonad.ùïã Mark) --FreeMonad.ùïã.pure (Mark.mk circle‚Çö) : FreeMonad.ùïã Mark
/- Aqui podemos ver incusive como √© essa transforma√ß√£o de Prim ‚Üí ùïã Mark
Primeiro o objeto Prim √© transformado em uma Mark e depois √© utilizado o pure
| pure : Œ± ‚Üí ùïã Œ±

De forma simples uma Monad √© uma solu√ß√£o para conseguir compor fun√ß√µes que retornam
valores com efeitos

class Monad (m : Type ‚Üí Type) where
  pure : Œ± ‚Üí m Œ± -- aplica o efeito a um valor puro
  bind : m Œ± ‚Üí (Œ± ‚Üí m Œ≤) ‚Üí m Œ≤ -- ajuda a compor fun√ß√µes que retornam valores com efeito

Podemos interpretar nossa ùïã Mark como uma √°rvore, e a opera√ß√£o pure √© a que pega
um Mark e adiciona a uma folha
-/

#check (circle‚Çò : FreeMonad.ùïã Mark) -- FreeMonad.ùïã.pure circle‚Çò : FreeMonad.ùïã Mark
-- Aqui ocorre o mesmo, s√≥ que n√£o precisamos transformar circle‚Çò em Mark

def ùïãcircle : FreeMonad.ùïã Mark := circle‚Çò

/- Vamos agora buscar desenhar nossos circles
Utilizamos para isso a ProofWidgets, em VizBackend temos duas fun√ß√µes de desenho
¬∑ drawsvg (Array Prim) (frame)
¬∑ draw (ùïã Mark) (frame)
(obs): Aqui seria interesante discutir sobre a necessidade de drawsvg
-/

#html drawsvg circle‚Çö
#html draw circle‚Çö

/- Como temos coer√ß√µes de Prim ‚Üí Mark e de Mark ‚Üí ùïã Mark, tanto drawsvg
quanto draw funcionam em prim, entretanto draw n√£o funcionaria em um ArrayPrim
#html draw circle‚Çê
application type mismatch
  @draw circle‚Çê
argument
  circle‚Çê
has type
  Array Prim : Type
but is expected to have type
  FreeMonad.ùïã Mark : Type 1
-/
#html draw circle‚Çò
#html draw ùïãcircle
/- Agora que temos como visualizar nossos "desenhos", vamos observar algumas
opera√ß√µes que temos dispon√≠veis
¬∑ Transla√ß√£o
¬∑ Rota√ß√£o
¬∑ Transforma√ß√µes de estilo
¬∑ Envelope e BoundBox
-/

-- Transla√ß√£o em Prim
def t_r‚ÇÅ : GeometricTransformation.G := GeometricTransformation.G.translate ‚äû[3,0] -- tr√™s unidade para a direita

-- Aplicamos transforma√ß√µes a esquerda do objeto Prim
#eval t_r‚ÇÅ * circle‚Çö
def circle‚Çötoright := t_r‚ÇÅ * circle‚Çö
#check circle‚Çötoright -- circle‚Çötoright : Prim
-- podemos ver as diferen√ßas
#html drawsvg circle‚Çö
#html drawsvg circle‚Çötoright
-- Vamos tentar verificar os objetos no mesmo frame
#check circle‚Çö ‚äï circle‚Çötoright -- circle‚Çö ‚äï circle‚Çötoright : Array Prim
def two_circles := circle‚Çö ‚äï circle‚Çötoright
#html drawsvg two_circles
-- Entretanto n√£o √© poss√≠vel  observ√°-los com draw, pois n√£o temos coe Array Prim ‚Üí ùïã Mark

-- Transla√ß√£o em Array Prim
#eval t_r‚ÇÅ * two_circles
#html drawsvg ( t_r‚ÇÅ * two_circles )
/- Aplicar uma transla√ß√£o em um Array Prim significa aplic√°-la a cada uma das componentes
  t * #[p‚ÇÅ , p‚ÇÇ] = #[t * p‚ÇÅ , t * p‚ÇÇ]
-/

-- Transla√ß√£o em Mark
#check ( t_r‚ÇÅ * circle‚Çò ) -- t_r‚ÇÅ * circle‚Çò : Array Prim
/- Quando aplicamos uma transla√ß√£o em um Mark, ele √© convertido para Array Prim
instance : HMul G Mark (Array Prim) where
  hMul g M  := g * M.Œ∏
-/
#html drawsvg ( t_r‚ÇÅ * circle‚Çò )
def circle‚Çòtoright := t_r‚ÇÅ * circle‚Çò
def twoMarkCircles := circle‚Çòtoright ‚äï circle‚Çò
#check twoMarkCircles -- twoMarkCircles : Array Prim
#html drawsvg twoMarkCircles
/-Isso nos mostra que o tipo Mark sozinho √© "inst√°vel" pois quase todas as aplica√ß√µes
em Mark retornam um Array Prim
No final veremos como funcionam as transforma√ß√µes em ùïã Mark
-/

-- Rota√ß√µes
set_default_scalar Float
open SciLean Scalar RealScalar in
def g_45 : GeometricTransformation.G := GeometricTransformation.G.rotate (œÄ/4)

-- Vamos precisar definir um novo objeto onde possamos ver os efeitos de rota√ß√£o
def square‚ÇÄ : Prim := NewPolygon #[‚äû[0.7,0.7],‚äû[-0.7,0.7],‚äû[-0.7,-0.7],‚äû[0.7,-0.7]]
#html drawsvg square‚ÇÄ
#check g_45 * square‚ÇÄ -- g_45 * square‚ÇÄ : Prim

def square·µ£ := g_45 * square‚ÇÄ
#html drawsvg square·µ£

-- Da mesma forma que em translate, a opera√ß√£o quando aplicada em um Array Prim, √© aplicada elemento a elemento
def square‚ÇÅ : Prim := t_r‚ÇÅ * square‚ÇÄ
def twoSquares := square‚ÇÄ ‚äï square‚ÇÅ
#html drawsvg (g_45 * twoSquares)

/- Observe que na rota√ß√£o vemos um efeito de transla√ß√£o no objeto,
isso ocorre pois o objeto √© rotacionado ao redor da origem
`importante: Verificar opera√ß√£o de rota√ß√£o`.
-/

-- Transforma√ß√£o de escala
def scale : GeometricTransformation.G := GeometricTransformation.G.scale 2
def bigSquare := scale * square‚ÇÄ
#html drawsvg bigSquare
#html drawsvg (scale * twoSquares)

-- Tamb√©m podemos compor transforma√ß√µes
#html drawsvg ( scale ‚àò g_45 ‚àò t_r‚ÇÅ * square‚ÇÄ )

-- Trasforma√ß√µes de estilo
/- Em `Style.lean` temos
structure Style where
  strokeColor := (none : Option Color)
  strokeWidth := (none : Option StyleSize)
  fillColor   := (none : Option Color)
-/

def borderToblue : Sty.Style := {strokeColor := Color.mk 0 0 1 }
#html drawsvg (borderToblue * bigSquare)

def size : Sty.StyleSize := .px 10
def bigborder : Sty.Style := {strokeWidth := size}
#html drawsvg ( bigborder * (borderToblue * bigSquare))

def Toblue : Sty.Style := {fillColor := Color.mk 0 0 1 }
#html drawsvg (Toblue * bigSquare)
/- As opera√ß√µes de estilo s√£o definidas utilizando rightOption

def rightOption {Œ± : Type} (o1 : Option Œ±) (o2 : Option Œ±) : Option Œ± :=
  match o2 with
  | none => o1
  | some a => some a

Portanto quando tentamos Toblue * bigSquare, nada acontece pois o criamos
utilizando NewPolygon que pre_seleciona fillColor
-/
def newSquare : Prim := {geom := Geom.polygon #[‚äû[0,0], ‚äû[2,0], ‚äû[2,2], ‚äû[0,2]] }
#eval newSquare
#html drawsvg newSquare -- Como NewSquare n√£o possui fill, n√£o √© poss√≠vel ver nada
#html drawsvg ( Toblue * newSquare )
-- Tamb√©m podemos compor diversos estilos
def redborder : Sty.Style := {strokeColor := Color.mk 1 0 0}
#eval redborder.comp Toblue
#html drawsvg ((redborder.comp Toblue) * (bigborder * newSquare))
#html drawsvg ( g_45 * ((redborder.comp Toblue) * (bigborder * newSquare)))

/- Envelope e BoundingBox
O envelope √© uma opera√ß√£o bastante interessante, ela pode ser utilizada para definirmos
o frame de nossos diagramas

O que √© o envelope ?
Dado uma dire√ß√£o, o envelope de um diagrama naquela dire√ß√£o √© a menor dist√¢ncia entre a origem e
a linha de separa√ß√£o ( Reta que divide o espa√ßo em dois, um contendo o diagrame e o outro vazio)
-/
#check (square‚ÇÄ : Geom) -- `instaciei Coe Prim Geom para esse exemplo `
#eval (envelope square‚ÇÄ ‚äû[1,1])
-- Para calcular o BoundingBox de um diagram, basta calcular o envelope em todas as dire√ß√µes
def BoundingBox_square‚ÇÄ := boundingBoxPrim square‚ÇÄ
#check BoundingBox_square‚ÇÄ
#html drawsvg square‚ÇÄ (BoundingBox.toFrame BoundingBox_square‚ÇÄ )
-- Vemos que o boundingbox de um square √© ele pr√≥prio

def bb_s45 := boundingBoxPrim (g_45 * square‚ÇÄ)
#html drawsvg (g_45 * square‚ÇÄ) (BoundingBox.toFrame bb_s45)
-- Entretanto quando rotacionamos, agora ele n√£o ocupa toda a caixa

-- Temos tamb√©m um para Array Prim `redundante`
def bb_2s := boundingBoxPrims twoSquares
#html drawsvg twoSquares (BoundingBox.toFrame bb_2s)
def bb_2s45 := boundingBoxPrims (g_45 * twoSquares)
#html drawsvg (g_45 * twoSquares) (BoundingBox.toFrame bb_2s45) -- `n√£o resolve problema de rota√ß√£o`

-- Outro uso para o envelope √© a capacidade posicionar um diagrama ao lado de outro
def h‚ÇÅ : Float^[2] := GeometricTransformation.normalize ‚äû[0,10]

-- Embora a fun√ß√£o envelope j√° normalize os vetores, a transla√ß√£o tem de usar o vetor normalizado
def limite_d‚ÇÅ : Float := envelope (scale * circle‚Çö) h‚ÇÅ
-- Calculamos o quanto o primeiro diagrama ( O que est√° fixo ) se estende na dire√ß√£o h‚ÇÅ
def limite_d‚ÇÇ : Float := envelope (circle‚Çö) (-h‚ÇÅ)
-- Calculamos o quanto o segundo diagrama ( O que desejamos posicionar ) se estende na dire√ß√£o oposta a h‚ÇÅ
def offset_h‚ÇÅ : Float := limite_d‚ÇÅ + limite_d‚ÇÇ
/-
Para garantir que D‚ÇÇ fique ‚Äúcolado‚Äù em D‚ÇÅ sem sobreposi√ß√£o, basta desloc√°-lo em v por uma dist√¢ncia igual a
Editar
offset = d1 + d2
Assim, a face mais pr√≥xima de D‚ÇÇ (na dire√ß√£o ‚Äìv) encosta exatamente na face mais avan√ßada de D‚ÇÅ (na dire√ß√£o v).-/
def position := offset_h‚ÇÅ * h‚ÇÅ

#eval position
#html drawsvg ( (scale * circle‚Çö) ‚äï ( (GeometricTransformation.G.translate position) * circle‚Çö))
def diagrama‚ÇÅ := ((scale * circle‚Çö) ‚äï ( (GeometricTransformation.G.translate position) * circle‚Çö))
#check diagrama‚ÇÅ
#eval diagrama‚ÇÅ
def bb_d := boundingBoxPrims diagrama‚ÇÅ
#html drawsvg (diagrama‚ÇÅ) (BoundingBox.toFrame bb_d)

/- # Desenvolvimento: Posicionamento por envelope
‚Üë ‚Üê ‚Üí ‚Üì
-/
def circle‚Çöpositioned := envelopePositionPrim circle‚Çö ‚äû[1,1] circle‚Çö
#html drawsvg ( circle‚Çö ‚äï circle‚Çöpositioned )

#html drawsvg ( circle‚Çö ‚Üí circle‚Çö ‚Üí circle‚Çö )
#html drawsvg ( circle‚Çö ‚Üí circle‚Çö ‚Üë square‚ÇÄ)
-- Tamb√©m podemos posicionar objetos com as opera√ß√µes ‚Üë ‚Üì ‚Üí ‚Üê adicionando um espa√ßamento
#html drawsvg ( circle‚Çö ‚Üí[0.5] circle‚Çö ‚Üí[0.5] circle‚Çö )

def stackCircles : Nat ‚Üí Float ‚Üí Array Prim
| 0,      _   => #[]                         -- zero c√≠rculos
| Nat.succ n, gap =>
  let prev := stackCircles n gap
  if prev.isEmpty then
    -- primeiro c√≠rculo
    #[circle‚Çö]
  else
    -- empilha mais um ap√≥s o que j√° existe
    prev ‚Üí[gap] #[circle‚Çö]

-- EXEMPLOS

#html drawsvg (circle‚Çö ‚Üí[0.5] circle‚Çö ‚Üí[0.5] circle‚Çö)
-- exatamente tr√™s c√≠rculos com gap = 0.5

def d := stackCircles 5 0.5   -- cinco c√≠rculos em fila, gap = 0.5
#html drawsvg d

-- 1) Constantes geom√©tricas do tri√¢ngulo equil√°tero de lado 1
def h : Float :=  (3 / 2 : Float).sqrt

-- 2) Tri√¢ngulo-base como Prim
def tri‚Çö : Prim := NewPolygon #[‚äû[0,0], ‚äû[1,0], ‚äû[0.5,h]]

/--
  Recurs√£o que, para n = 0, retorna o tri√¢ngulo √∫nico;
  para n+1,k produz tr√™s c√≥pias de ordem n escaladas a ¬Ω,
  deslocadas para (0,0), (0.5,0) e (0.25,h/2).
-/
def sierpinskiPrims : Nat ‚Üí Array Prim
| 0   => #[tri‚Çö]
| n+1 =>
  let prev := sierpinskiPrims n
  -- escala tudo em 0.5
  let scaled := prev.map (fun p => { geom := GeometricTransformation.G.scale 0.5 * p.geom, s := p.s })
  -- tr√™s posi√ß√µes
  let t1 := scaled
  let t2 := scaled.map (fun p => { geom := GeometricTransformation.G.translate ‚äû[0.5,0]  * p.geom, s := p.s })
  let t3 := scaled.map (fun p => { geom := GeometricTransformation.G.translate ‚äû[0.25,h/2] * p.geom, s := p.s })
  -- concatena
  t1 ++ t2 ++ t3

#html drawsvg (sierpinskiPrims 5) (BoundingBox.toFrame (boundingBoxPrims (sierpinskiPrims 5)))

/- Transla√ß√£o em ùïã Mark
Em FreeMonad, temos:
structure H where -- Tranforma√ß√µes Gr√°ficas
  s : Style
  g : G

Isso rege as transforma√ß√µes em objetos do tipo ùïã Mark
-/

-- Vamos voltar a olhar para os objetos do tipo ùïã Mark
#check ùïãcircle
#html draw ùïãcircle

-- Como aplicar uma transforma√ß√£o em ùïãcircle ?
def ùïãtranslation (x : Float^[2]) : FreeMonad.H := { s := {} , g := GeometricTransformation.G.translate x}
def x : Float^[2]:= ‚äû[2,0]
#html draw ( ùïãtranslation x * ùïãcircle )
#check ( ùïãtranslation x * ùïãcircle )
/- # O que estamos fazendo ?
Intuitivamente, compor marcas √© como criar uma arvore
inicialmente temos:

        circle

Mas ap√≥s a opera√ß√£o ùïãtranslation

    H
      \
        circle


def eval (t : FreeMonad.ùïã Mark) : Array Prim :=
  FreeMonad.algŒ∏ (FreeMonad.ùïã.map Mark.Œ∏ t)

#eval eval ( ùïãtranslation x * ùïãcircle )
-/
def twoCircles : FreeMonad.ùïã Mark := ùïãcircle + ( ùïãtranslation x * ùïãcircle )
#html draw twoCircles
/- # Arvore de twoCircles

      ùïã.comp
    /        \
ùïãcircle     ùïã.act H
                \
              ùïãcircle
-/
-- Da mesma forma, podemos verificar as outras transforma√ß√µes geom√©tricas
def ùïãrotate (y : Float) : FreeMonad.H := { s := {} , g := GeometricTransformation.G.rotate y}
def ùïãscale (z : Float) : FreeMonad.H := { s := {} , g := GeometricTransformation.G.scale z}

def ùïãsquare : FreeMonad.ùïã Mark := square‚ÇÄ

open SciLean Scalar RealScalar in
#html draw ( ùïãrotate (œÄ/4) * ùïãsquare)
#html draw (ùïãscale 0.3 * ùïãcircle)

-- Vemos tamb√©m transforma√ß√µes de estilo
/- # Transforma√ß√µes de estilo em Marks
Aqui ainda utilizamos
instance : Mul H where
  mul x y := H.mk (Style.comp x.s y.s) ( x.g )
`Style.comp` para combinar os estilos, portanto permanece o rightOption
-/
def ùïãstyle (w : Sty.Style) : FreeMonad.H := { s := w , g := GeometricTransformation.G.scale 1}
def myStyle : Sty.Style := {strokeColor := Color.mk 0 0 1 , fillColor := Color.mk 1 1 0}

#html draw (ùïãstyle borderToblue * ùïãsquare)
#html draw (ùïãstyle borderToblue * ùïãstyle bigborder * ùïãsquare)

/- # Envelopes e BoundingBox -/
def blueBorderSquare : FreeMonad.ùïã Mark := (ùïãstyle borderToblue * ùïãstyle bigborder * ùïãsquare)

/- Da mesma forma que em Prim e Array Prim, podemos utilizar uma fun√ß√£o para calcular o
boundingbox e ent√£o converter para frame -/
def bb_m‚ÇÅ := FreeMonad.boundingBoxùïã blueBorderSquare
def bb_m‚ÇÇ := FreeMonad.boundingBoxùïã twoCircles
#html draw blueBorderSquare (BoundingBox.toFrame bb_m‚ÇÅ)
#html draw twoCircles (BoundingBox.toFrame bb_m‚ÇÇ)

/- Tamb√©m temos os posicionamentos por envelope -/
#html draw ( twoCircles + FreeMonad.envelopePositionMarks twoCircles ‚äû[0,1] twoCircles)
#html draw (twoCircles ‚Üí twoCircles ‚Üë twoCircles )
#html draw (twoCircles ‚Üë ùïãsquare)

-- Posicionando com espa√ßamento
def bb_m‚ÇÉ := FreeMonad.boundingBoxùïã ( twoCircles ‚Üë[0.5] twoCircles)
#html draw ( twoCircles ‚Üë[0.5] twoCircles) (BoundingBox.toFrame bb_m‚ÇÉ)
